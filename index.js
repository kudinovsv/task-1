const getPointPos = function getPointPos(num) {
/**
 * функция возвращает позицию точки в строке содержащей число. если точки нет, это значит что
 * число целое и неявно она находится сразу после последнего символа, поэтому возвращается
 * позиция следующая за последним символом (отсутствующая в строке)
 */
  let result = num.indexOf('.');
  if (result === -1) result = num.length;
  return result;
};

const add = function add(xValue, yValue) {
/**
 * функция складывает два неотрицательных числа в строковом представлении. работает с числами
 * любой длины без какой-либо погрешности. сложение осуществляется столбиком. числа должны быть
 * без ведущих нолей (иначе результат также будет содержать ведущие ноли). непрерывные
 * последовательности нолей произвольной длины в конце дробной части допускаются, т.е. функция при
 * формировании результата их отбрасывает. допустимыми значениями операндов явлются строки
 * '' (пустая) и '.' (содержащая одну точку), оба этих значения трактуются как ноль. если целая
 * часть равна нолю, число должно начинаться либо с точки '.xxxx...' либо с ноля-точки '0.xxxxx',
 * т.е. точке должен предшествовать максимум один ноль.
 */

  // преобразуем операнды в объекты вида { value: исходное_значение, pointPos: позиция_точки }
  const [x, y] = [xValue, yValue].map(value => ({ value, pointPos: getPointPos(value) }));

  /**
   * максимум из длин дробных частей: -1 при отсутствии дробных частей, 0 при присуствии в конце
   * хотя бы одного из операндов только лишь точки, 1 если у хотябы одного из них есть один разряд
   * после точки, 2, 3, и т.д.
   */
  let max = Math.max(x.value.length - x.pointPos - 1, y.value.length - y.pointPos - 1);
  /**
   * если дробных частей нет, а есть только точка в конце (хотя бы у одного), не будем принимать
   * её во внимание, чтобы она не попала в результат:
   */
  if (max === 0) max = -1;

  /**
   * максимум из длин целых частей и единицы (со знаком минус). единица нужна чтобы при отсутсвии
   * у операндов целой части (pointPos === 0) гарантированно сформировался один разряд целой части.
   * диапазон значений: -1, -2, -3 и т.д.
   */
  const min = -Math.max(x.pointPos, y.pointPos, 1);

  // флаг переноса единицы в старший разряд (0 или 1)
  let carry = 0;
  // флаг отбрасывания нолей. устанвливаем в true только если имеется дробная часть
  let ignoreZeros = max > 0;
  // переменная для формирования результата
  let res = '';

  // итерируемся по всем присутствующим разрядам справа налево
  for (let i = max; i >= min; i -= 1) {
    if (i === 0) { // мы в разряде точки?
      // да. если уже не отбрасываем ноли, добавляем точку к результату
      if (!ignoreZeros) res = `.${res}`;
      // больше не будем отбрасывать ноли т.к. дальше пойдёт целая часть
      ignoreZeros = false;
    } else {
      // нет, мы не в разряде точки. складываем цирфы разряда:
      let sum = carry
        + Number(x.value.charAt(x.pointPos + i))
        + Number(y.value.charAt(y.pointPos + i));

      if (sum > 9) { // сумма больше девяти?
        // да. значит в следующиий разряд пойдёт дополнительная единица
        carry = 1;
        // а в текущий остаток от деления на 10
        sum %= 10;
      } else {
        // нет. значит переноса в следующий разряд не будет
        carry = 0;
      }

      if (!ignoreZeros || sum !== 0) { // больше не отбрасываем ноли, или получили не ноль?
        // да. добавляем полученную цифру к результату
        res = `${sum}${res}`;
        // и больше не будем отбрасывать ноли
        ignoreZeros = false;
      } // если же нет - получили ноль и мы ещё отбрасываем ноли, тогда просто игнорируем его
    }
  }

  // если осталась единица для страшего разряда, добавим её
  if (carry) res = `1${res}`;

  return res;
};

const trimLeftZeros = function trimLeftZeros(str) {
/**
 * функкция отбрасывает ноли в начале строки: '001.35' => '1.35', '0.' => '.', '0' => ''
 * используется при подготовке опернадов функции add
 */
  let result = str;
  while (result[0] === '0') result = result.substr(1);
  return result;
};

const prepareNumber = function prepareNumber(num) {
/**
 * функция подготавливает операнд для функции add:
 * обрезает пробелы в начале и в конце, заменяет запятутю на точку, далее осуществляет провеку на
 * число (если это не число бросает исключение), и наконец отбрасывает начальные нули с помощью
 * функции trimLeftZeros
 */
  const result = num.trim().replace(',', '.');
  const jsNumber = Number(result);
  if (result === '' || Number.isNaN(jsNumber)) throw new Error('Слагаемые введены некорректно');
  if (jsNumber < 0) throw new Error('Данная реализация поддерживает только неотрицательные числа');
  return trimLeftZeros(result);
};

const buttonClick = function buttonClick() {
// обработчик клика по кнопке

  const form = document.forms[0];
  let x;
  let y;
  try {
    // считываем операнды из полей ввода и подготоваливаем их с помощью функции prepareNumber
    [x, y] = ['x', 'y'].map(name => prepareNumber(form[name].value));
  } catch ({ message }) {
    alert(message);
    return;
  }

  alert(`Результат:\n\n${add(x, y)}`);
};

document.forms[0].button.addEventListener('click', buttonClick);
